name: Deploy to ECS (Fargate)

on:
  push:
    branches: [development]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: ${{ github.ref == 'refs/heads/main' && 'sa-east-1' || 'us-east-1' }}
      ECR_REPO_PHP: ${{ github.ref == 'refs/heads/main' && 'rossi-api-php' || 'dev-rossi-api-php' }}
      ECR_REPO_NGINX: ${{ github.ref == 'refs/heads/main' && 'rossi-api-nginx' || 'dev-rossi-api-nginx' }}
      ECS_CLUSTER: ${{ github.ref == 'refs/heads/main' && 'rossi-api-cluster' || 'dev-rossi-api-cluster' }}
      ECS_SERVICE: ${{ github.ref == 'refs/heads/main' && 'rossi-api-svc' || 'dev-rossi-api-svc' }}
      PROJECT_NAME: ${{ github.ref == 'refs/heads/main' && 'rossi-api' || 'dev-rossi-api' }}
      DOCKERFILE_PHP: ./Dockerfile
      DOCKERFILE_NGINX: ./Dockerfile.nginx
      PHP_CONTAINER_NAME: php-fpm
      NGINX_CONTAINER_NAME: nginx

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ github.ref == 'refs/heads/main' && secrets.AWS_ROLE_ARN_PROD || secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Discover infrastructure (subnets, security groups)
        id: discover
        run: |
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Project,Values=$PROJECT_NAME" \
            --query 'Vpcs[0].VpcId' --output text)
          echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV

          ECS_NETWORK_CONFIG=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --query 'services[0].networkConfiguration.awsvpcConfiguration')

          CURRENT_SUBNETS=$(echo "$ECS_NETWORK_CONFIG" | jq -r '.subnets | join(",")')
          CURRENT_SECURITY_GROUPS=$(echo "$ECS_NETWORK_CONFIG" | jq -r '.securityGroups | join(",")')
          ASSIGN_PUBLIC_IP=$(echo "$ECS_NETWORK_CONFIG" | jq -r '.assignPublicIp')

          echo "CURRENT_SUBNETS=$CURRENT_SUBNETS" >> $GITHUB_ENV
          echo "CURRENT_SECURITY_GROUPS=$CURRENT_SECURITY_GROUPS" >> $GITHUB_ENV
          echo "ASSIGN_PUBLIC_IP=$ASSIGN_PUBLIC_IP" >> $GITHUB_ENV

          if [ "$ASSIGN_PUBLIC_IP" = "ENABLED" ]; then
            PUBLIC_SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:Project,Values=$PROJECT_NAME" \
              --query 'Subnets[?MapPublicIpOnLaunch==`true`].SubnetId' --output text | tr '\t' ',')
            echo "MIGRATION_SUBNETS=$PUBLIC_SUBNETS" >> $GITHUB_ENV
          else
            # Use the same subnets as the service (private subnets)
            echo "MIGRATION_SUBNETS=$CURRENT_SUBNETS" >> $GITHUB_ENV
          fi

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push images (php-fpm + nginx)
        id: build
        run: |
          IMAGE_TAG=${GITHUB_SHA::7}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

          PHP_ECR_URI=$(aws ecr describe-repositories --repository-names "$ECR_REPO_PHP" --query 'repositories[0].repositoryUri' --output text)
          NGINX_ECR_URI=$(aws ecr describe-repositories --repository-names "$ECR_REPO_NGINX" --query 'repositories[0].repositoryUri' --output text)
          echo "PHP_ECR_URI=$PHP_ECR_URI" >> $GITHUB_ENV
          echo "NGINX_ECR_URI=$NGINX_ECR_URI" >> $GITHUB_ENV

          docker build -f "$DOCKERFILE_PHP"   -t "$PHP_ECR_URI:$IMAGE_TAG"   .
          docker build -f "$DOCKERFILE_NGINX" -t "$NGINX_ECR_URI:$IMAGE_TAG" .

          docker push "$PHP_ECR_URI:$IMAGE_TAG"
          docker push "$NGINX_ECR_URI:$IMAGE_TAG"

      - name: Read current Task Definition (base)
        id: getdef
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --query 'services[0].taskDefinition' --output text)
          echo "TD_ARN=$TD_ARN" >> $GITHUB_ENV

          aws ecs describe-task-definition --task-definition "$TD_ARN" \
            --query 'taskDefinition' > base.json

          jq '{
            family: .family,
            taskRoleArn: .taskRoleArn,
            executionRoleArn: .executionRoleArn,
            networkMode: .networkMode,
            containerDefinitions: .containerDefinitions,
            volumes: .volumes,
            placementConstraints: .placementConstraints,
            requiresCompatibilities: .requiresCompatibilities,
            cpu: .cpu,
            memory: .memory,
            pidMode: .pidMode,
            ipcMode: .ipcMode,
            proxyConfiguration: .proxyConfiguration,
            inferenceAccelerators: .inferenceAccelerators,
            ephemeralStorage: .ephemeralStorage,
            runtimePlatform: .runtimePlatform,
            enableFaultInjection: .enableFaultInjection
          } | with_entries(select(.value != null))' base.json > allow.json

      - name: Replace container images and register
        run: |
          NEW=$(jq \
            --arg PHP "${PHP_ECR_URI}:${IMAGE_TAG}" \
            --arg NGX "${NGINX_ECR_URI}:${IMAGE_TAG}" \
            --arg PHP_NAME "${PHP_CONTAINER_NAME}" \
            --arg NGX_NAME "${NGINX_CONTAINER_NAME}" \
            '.containerDefinitions = (
              .containerDefinitions
              | map(
                  if .name == $PHP_NAME then .image = $PHP
                  elif .name == $NGX_NAME then .image = $NGX
                  else .
                  end
                )
            )' allow.json)
          echo "$NEW" > new.json

          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_ENV

          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_SERVICE" \
            --task-definition "$NEW_TD_ARN" \
            --query 'service.taskDefinition' --output text

          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --cli-read-timeout 1200 \
            --cli-connect-timeout 60

      # Dynamic migrations with discovered network configuration
      - name: Run migrations (one-off)
        if: ${{ success() }}
        run: |
          SUBNETS_JSON=$(echo "$MIGRATION_SUBNETS" | tr ',' '\n' | jq -R . | jq -s .)
          SECURITY_GROUPS_JSON=$(echo "$CURRENT_SECURITY_GROUPS" | tr ',' '\n' | jq -R . | jq -s .)

          aws ecs run-task \
            --cluster "$ECS_CLUSTER" \
            --launch-type FARGATE \
            --task-definition "$NEW_TD_ARN" \
            --network-configuration "{\"awsvpcConfiguration\":{\"subnets\":$SUBNETS_JSON,\"securityGroups\":$SECURITY_GROUPS_JSON,\"assignPublicIp\":\"$ASSIGN_PUBLIC_IP\"}}" \
            --overrides "{\"containerOverrides\":[{\"name\":\"$PHP_CONTAINER_NAME\",\"command\":[\"php\",\"artisan\",\"migrate\",\"--force\"]}]}"
